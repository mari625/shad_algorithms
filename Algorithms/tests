5 10
ljkfghdfas
isdfjksiye
pgljkijlgp
eyisdafdsi
lnpglkfkjl

// 3  1 1  3 3

1 10
aaaaaaaaaa

2 10
aaaaaaaaaa
aaaaaaaaaa

1 3
adv

2 4
abab
abab

8 8
ccccgctk
cccccgwo
ccccccgu
cccccccg
gccccccc
wgcccccc
wagccccc
ccjgcccc

9 9
gmgbdbdbd
gccdbxbeb
halbdbdbd
bdbdbdfdb
dhdbdidbd
bdbdbdbdb
gmgkdbgmg
gccdbdgcc
halbdbhal

9 9
gmgbdbdbd
gccdbxbeb
halbdbdbd
bdbdbdfdb
dhdbdidbd
bdbdbdbdb
mmgkdbgmg
gccdbdgcc
halbdbhal

/* #include <cstdint>
#include <iostream>
#include <vector>
#include <random>
#include <unordered_map>

struct Point {
    int x = 0;
    int y = 0;
};

struct SquaresAndSize {
    Point first;
    Point second;
    int size = 0;
};

class HashFunction {
private:
    int x_;
    int y_;
    int64_t p_;
    int m_;
    std::mt19937 generator_;
    const int kSeed = 75837;

    std::vector<std::vector<int>> x_y_degrees_;
    std::vector<std::vector<int>> square_hashes_;

    void PrecomputeDegrees(int length, int height) {
        x_y_degrees_.resize(length, std::vector<int>(height));
        x_y_degrees_[0][0] = 1;

        for (int i = 0; i < length; ++i) {
            if (i != 0) {
                x_y_degrees_[i][0] = static_cast<int>((static_cast<int64_t>(x_y_degrees_[i - 1][0]) * static_cast<int64_t>(x_)) % p_);
            }

            for (int j = 1; j < height; ++j) {
                x_y_degrees_[i][j] = static_cast<int>((static_cast<int64_t>(x_y_degrees_[i][j - 1]) * static_cast<int64_t>(y_)) % p_);
            }
        }

        std::cout<<x_<<" " <<y_<<'\n';

        for (int i = 0; i < length; ++i) {
            for (int j = 0; j < height; ++j) {
                std::cout << i<<" "<<j<<" "<<x_y_degrees_[i][j]<<'\n';
            }
        }
    }

public:

    HashFunction(int64_t p_parameter, int length, int heigth) {
        generator_.seed(kSeed);
        p_ = p_parameter;
        m_ = length*heigth;
        x_ = std::uniform_int_distribution<int64_t>(1, p_ - 1)(generator_);
        y_ = std::uniform_int_distribution<int64_t>(1, p_ - 1)(generator_);

        PrecomputeDegrees(length, heigth);
        //std::cout<<"a"<<'\n';

    }

    void PrecomputeSquareHashes(int length, int height, std::vector<std::vector<char>>& matrix) { ///degrees of 2
        square_hashes_.resize(length, std::vector<int>(height, 0));

        square_hashes_[0][0] = matrix[0][0] - '0';

        for (int i = 0; i < length; ++i) {
            if (i != 0) {
                square_hashes_[i][0] = static_cast<int>((static_cast<int64_t>(square_hashes_[i - 1][0]) + static_cast<int64_t>(matrix[i][0] - '0') * static_cast<int64_t>(x_y_degrees_[i][0])) % p_);
            }

            for (int j = 1; j < height; ++j) {
                int add = square_hashes_[i][j - 1];

                if (i != 0) {
                    add += square_hashes_[i - 1][j];
                    add -= square_hashes_[i - 1][j - 1];
                }

                //!!!!! cast temp
                square_hashes_[i][j] = static_cast<int>((static_cast<int64_t>(add) + static_cast<int64_t>(matrix[i][j] - '0') * static_cast<int64_t>(x_y_degrees_[i][j])) % p_);
            }
        }

        for (int i = 0; i < length; ++i) {
            for (int j = 0; j < height; ++j) {
                std::cout << i<<" "<<j<<" "<<square_hashes_[i][j]<<'\n';
            }
        }
    }

    int operator()(int i_index, int j_index) const {
        if (i_index < 0 || j_index < 0) {
            return 0;
        }

        //std::cout<<i_index<<" "<<j_index<<" indexes"<<'\n';
        return square_hashes_[i_index][j_index];
    }

    int operator()(int x_1, int y_1, int k_size, int length, int height) const {
        int x_2 = x_1 + k_size;
        int y_2 = y_1 + k_size;
        //std::cout<<x_1<<" "<<y_1<<" "<<x_2<<" "<<y_2<<'\n';
        //std::cout<<operator()(x_2, y_2)<<" "<<operator()(x_1 - 1, y_2)<<" "<<operator()(x_2, y_1 - 1)<<" "<<operator()(x_1 - 1, y_1 - 1)<<'\n';
        //std::cout<<static_cast<int64_t>(x_y_degrees_[length - 1 - x_2][height - 1 - y_2])<<'\n';
        return  static_cast<int>((static_cast<int64_t>(operator()(x_2, y_2) - operator()(x_1 - 1, y_2)
         - operator()(x_2, y_1 - 1) + operator()(x_1 - 1, y_1 - 1) + p_* 2) * static_cast<int64_t>(x_y_degrees_[length - 1 - x_2][height - 1 - y_2])) % p_) % m_;
    }
};

bool SquaresEqual(Point first, Point second, std::vector<std::vector<char>>& matrix, int size_k) {
    for (int i = 0; i < size_k; ++i) {
        for (int j = 0; j < size_k; ++j) {
            std::cout<<matrix[first.x + i][first.y + j]<<" "<<matrix[second.x + i][second.y + j]<<'\n';
            if (matrix[first.x + i][first.y + j] != matrix[second.x + i][second.y + j]) {
                return false;
            }
        }
    }
    return true;
}

SquaresAndSize FindSquares(int length, int height, std::vector<std::vector<char>>& matrix) {
    SquaresAndSize answer;

    const int kBigConstant = 250007;
    HashFunction hash_function = HashFunction(kBigConstant, length, height);
    //std::cout<<"a"<<'\n';

    hash_function.PrecomputeSquareHashes(length, height, matrix);
    //std::cout<<"a"<<'\n';

    for (int k = 1; k <= std::min(length, height); ++k) {
        std::cout<<"k "<<k<<'\n';
        std::unordered_map<int, std::vector<Point>> map;
        bool hash_again = false;

        int i_iterator = 0;
        while (i_iterator <= length - k && !hash_again) {
            int j_iterator = 0;
            while (j_iterator <= height - k && !hash_again) {
                int current_hash = hash_function(i_iterator, j_iterator, k - 1, length, height);
                //std::cout<<"a"<<'\n';

                std::cout<<current_hash<<" "<<i_iterator<<" "<<j_iterator<<'\n';

                if (map[current_hash].empty()) {
                    map[current_hash].push_back(Point{i_iterator,j_iterator});
                } else {
                    for (int iter = 0; iter < std::ssize(map[current_hash]); ++iter) {
                        //std::cout<<SquaresEqual(Point{i_iterator, j_iterator}, map[current_hash][iter], matrix, k)<<'\n';

                        if (SquaresEqual(Point{i_iterator, j_iterator}, map[current_hash][iter], matrix, k)) {
                            answer.first = Point{i_iterator, j_iterator};
                            answer.second = map[current_hash][iter];
                            answer.size = k;
                            hash_again = true;
                            break;
                        }
                    }
                    map[current_hash].push_back(Point{i_iterator,j_iterator});
                }
                ++j_iterator;
            }
            ++i_iterator;
        }
    }

    return answer;
}

int main() {
    int length = 0;
    int height = 0;
    std::cin >> length >> height;

    std::vector<std::vector<char>> matrix(length, std::vector<char>(height, 0));

    for (int i = 0; i < length; ++i) {
        for (int j = 0; j < height; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    SquaresAndSize answer = FindSquares(length, height, matrix);

    if (answer.size == 0) {
        std::cout << '0' <<'\n';
    } else {
        std::cout << answer.size << '\n';
        std::cout << answer.first.x + 1 << " " << answer.first.y + 1 << '\n';
        std::cout << answer.second.x + 1 << " " << answer.second.y + 1 << '\n';
    }
    return 0;
} */